import{i as E}from"./is-plain-object-C7BF5Ngm.js";function O(){return O=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},O.apply(this,arguments)}function w(e,n){if(e==null)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n.indexOf(t=o[r])>=0||(i[t]=e[t]);return i}const N={silent:!1,logLevel:"warn"},S=["validator"],P=Object.prototype,x=P.toString,V=P.hasOwnProperty,q=/^\s*function (\w+)/;function T(e){var n;const t=(n=e?.type)!==null&&n!==void 0?n:e;if(t){const r=t.toString().match(q);return r?r[1]:""}return""}const p=E,k=e=>e;let f=k;const h=(e,n)=>V.call(e,n),D=Number.isInteger||function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e},b=Array.isArray||function(e){return x.call(e)==="[object Array]"},g=e=>x.call(e)==="[object Function]",m=e=>p(e)&&h(e,"_vueTypes_name"),A=e=>p(e)&&(h(e,"type")||["_vueTypes_name","validator","default","required"].some(n=>h(e,n)));function _(e,n){return Object.defineProperty(e.bind(n),"__original",{value:e})}function v(e,n,t=!1){let r,i=!0,o="";r=p(e)?e:{type:e};const u=m(r)?r._vueTypes_name+" - ":"";if(A(r)&&r.type!==null){if(r.type===void 0||r.type===!0||!r.required&&n===void 0)return i;b(r.type)?(i=r.type.some(a=>v(a,n,!0)===!0),o=r.type.map(a=>T(a)).join(" or ")):(o=T(r),i=o==="Array"?b(n):o==="Object"?p(n):o==="String"||o==="Number"||o==="Boolean"||o==="Function"?function(a){if(a==null)return"";const s=a.constructor.toString().match(q);return s?s[1]:""}(n)===o:n instanceof r.type)}if(!i){const a=`${u}value "${n}" should be of type "${o}"`;return t===!1?(f(a),!1):a}if(h(r,"validator")&&g(r.validator)){const a=f,s=[];if(f=l=>{s.push(l)},i=r.validator(n),f=a,!i){const l=(s.length>1?"* ":"")+s.join(`
* `);return s.length=0,t===!1?(f(l),i):l}}return i}function c(e,n){const t=Object.defineProperties(n,{_vueTypes_name:{value:e,writable:!0},isRequired:{get(){return this.required=!0,this}},def:{value(i){return i===void 0?(h(this,"default")&&delete this.default,this):g(i)||v(this,i,!0)===!0?(this.default=b(i)?()=>[...i]:p(i)?()=>Object.assign({},i):i,this):(f(`${this._vueTypes_name} - invalid default value: "${i}"`),this)}}}),{validator:r}=t;return g(r)&&(t.validator=_(r,t)),t}function d(e,n){const t=c(e,n);return Object.defineProperty(t,"validate",{value(r){return g(this.validator)&&f(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`),this.validator=_(r,this),this}})}function $(e,n,t){const r=function(s){const l={};return Object.getOwnPropertyNames(s).forEach(y=>{l[y]=Object.getOwnPropertyDescriptor(s,y)}),Object.defineProperties({},l)}(n);if(r._vueTypes_name=e,!p(t))return r;const{validator:i}=t,o=w(t,S);if(g(i)){let{validator:s}=r;s&&(s=(a=(u=s).__original)!==null&&a!==void 0?a:u),r.validator=_(s?function(l){return s.call(this,l)&&i.call(this,l)}:i,r)}var u,a;return Object.assign(r,o)}function j(e){return e.replace(/^(?!\s*$)/gm,"  ")}const F=()=>d("any",{}),L=()=>d("function",{type:Function}),Y=()=>d("boolean",{type:Boolean}),B=()=>d("string",{type:String}),I=()=>d("number",{type:Number}),J=()=>d("array",{type:Array}),M=()=>d("object",{type:Object}),R=()=>c("integer",{type:Number,validator:e=>D(e)}),z=()=>c("symbol",{validator:e=>typeof e=="symbol"});function C(e,n="custom validation failed"){if(typeof e!="function")throw new TypeError("[VueTypes error]: You must provide a function as argument");return c(e.name||"<<anonymous function>>",{type:null,validator(t){const r=e(t);return r||f(`${this._vueTypes_name} - ${n}`),r}})}function G(e){if(!b(e))throw new TypeError("[VueTypes error]: You must provide an array as argument.");const n=`oneOf - value should be one of "${e.join('", "')}".`,t=e.reduce((r,i)=>{if(i!=null){const o=i.constructor;r.indexOf(o)===-1&&r.push(o)}return r},[]);return c("oneOf",{type:t.length>0?t:void 0,validator(r){const i=e.indexOf(r)!==-1;return i||f(n),i}})}function H(e){if(!b(e))throw new TypeError("[VueTypes error]: You must provide an array as argument");let n=!1,t=[];for(let i=0;i<e.length;i+=1){const o=e[i];if(A(o)){if(m(o)&&o._vueTypes_name==="oneOf"&&o.type){t=t.concat(o.type);continue}if(g(o.validator)&&(n=!0),o.type===!0||!o.type){f('oneOfType - invalid usage of "true" or "null" as types.');continue}t=t.concat(o.type)}else t.push(o)}t=t.filter((i,o)=>t.indexOf(i)===o);const r=t.length>0?t:null;return c("oneOfType",n?{type:r,validator(i){const o=[],u=e.some(a=>{const s=v(m(a)&&a._vueTypes_name==="oneOf"?a.type||null:a,i,!0);return typeof s=="string"&&o.push(s),s===!0});return u||f(`oneOfType - provided value does not match any of the ${o.length} passed-in validators:
${j(o.join(`
`))}`),u}}:{type:r})}function K(e){return c("arrayOf",{type:Array,validator(n){let t="";const r=n.every(i=>(t=v(e,i,!0),t===!0));return r||f(`arrayOf - value validation error:
${j(t)}`),r}})}function Q(e){return c("instanceOf",{type:e})}function U(e){return c("objectOf",{type:Object,validator(n){let t="";const r=Object.keys(n).every(i=>(t=v(e,n[i],!0),t===!0));return r||f(`objectOf - value validation error:
${j(t)}`),r}})}function W(e){const n=Object.keys(e),t=n.filter(i=>{var o;return!((o=e[i])===null||o===void 0||!o.required)}),r=c("shape",{type:Object,validator(i){if(!p(i))return!1;const o=Object.keys(i);if(t.length>0&&t.some(u=>o.indexOf(u)===-1)){const u=t.filter(a=>o.indexOf(a)===-1);return f(u.length===1?`shape - required property "${u[0]}" is not defined.`:`shape - required properties "${u.join('", "')}" are not defined.`),!1}return o.every(u=>{if(n.indexOf(u)===-1)return this._vueTypes_isLoose===!0||(f(`shape - shape definition does not include a "${u}" property. Allowed keys: "${n.join('", "')}".`),!1);const a=v(e[u],i[u],!0);return typeof a=="string"&&f(`shape - "${u}" property validation error:
 ${j(a)}`),a===!0})}});return Object.defineProperty(r,"_vueTypes_isLoose",{writable:!0,value:!1}),Object.defineProperty(r,"loose",{get(){return this._vueTypes_isLoose=!0,this}}),r}const X=["name","validate","getter"],Z=(()=>{var e;return(e=class{static get any(){return F()}static get func(){return L().def(this.defaults.func)}static get bool(){return Y().def(this.defaults.bool)}static get string(){return B().def(this.defaults.string)}static get number(){return I().def(this.defaults.number)}static get array(){return J().def(this.defaults.array)}static get object(){return M().def(this.defaults.object)}static get integer(){return R().def(this.defaults.integer)}static get symbol(){return z()}static get nullable(){return{type:null}}static extend(n){if(b(n))return n.forEach(s=>this.extend(s)),this;const{name:t,validate:r=!1,getter:i=!1}=n,o=w(n,X);if(h(this,t))throw new TypeError(`[VueTypes error]: Type "${t}" already defined`);const{type:u}=o;if(m(u))return delete o.type,Object.defineProperty(this,t,i?{get:()=>$(t,u,o)}:{value(...s){const l=$(t,u,o);return l.validator&&(l.validator=l.validator.bind(l,...s)),l}});let a;return a=i?{get(){const s=Object.assign({},o);return r?d(t,s):c(t,s)},enumerable:!0}:{value(...s){const l=Object.assign({},o);let y;return y=r?d(t,l):c(t,l),l.validator&&(y.validator=l.validator.bind(y,...s)),y},enumerable:!0},Object.defineProperty(this,t,a)}}).defaults={},e.sensibleDefaults=void 0,e.config=N,e.custom=C,e.oneOf=G,e.instanceOf=Q,e.oneOfType=H,e.arrayOf=K,e.objectOf=U,e.shape=W,e.utils={validate:(n,t)=>v(t,n,!0)===!0,toType:(n,t,r=!1)=>r?d(n,t):c(n,t)},e})();function ee(e={func:()=>{},bool:!0,string:"",number:0,array:()=>[],object:()=>({}),integer:0}){var n;return(n=class extends Z{static get sensibleDefaults(){return O({},this.defaults)}static set sensibleDefaults(t){this.defaults=t!==!1?O({},t!==!0?t:e):{}}}).defaults=O({},e),n}class re extends ee(){}export{re as C};
