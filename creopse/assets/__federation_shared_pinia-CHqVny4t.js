import{i as ot}from"./ckeditor_ckeditor5-vue-D9YIFk5Z.js";/*!
 * pinia v3.0.2
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */const{hasInjectionContext:B,inject:D,toRaw:J,watch:st,unref:_t,markRaw:q,effectScope:z,ref:G,isRef:R,isReactive:L,getCurrentScope:rt,onScopeDispose:ct,getCurrentInstance:jt,reactive:ut,toRef:it,nextTick:ft,computed:Q,toRefs:at}=await ot("vue");let W;const A=t=>W=t,Pt=()=>B()&&D(H)||W,H=Symbol();function $(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var x;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(x||(x={}));function gt(){const t=z(!0),o=t.run(()=>G({}));let n=[],e=[];const s=q({install(c){A(s),s._a=c,c.provide(H,s),c.config.globalProperties.$pinia=s,e.forEach(i=>n.push(i)),e=[]},use(c){return this._a?n.push(c):e.push(c),this},_p:n,_a:null,_e:t,_s:new Map,state:o});return s}function pt(t){t._e.stop(),t._s.clear(),t._p.splice(0),t.state.value={},t._a=null}function Ct(t,o){return()=>{}}const X=()=>{};function U(t,o,n,e=X){t.push(o);const s=()=>{const c=t.indexOf(o);c>-1&&(t.splice(c,1),e())};return!n&&rt()&&ct(s),s}function g(t,...o){t.slice().forEach(n=>{n(...o)})}const lt=t=>t(),V=Symbol(),I=Symbol();function O(t,o){t instanceof Map&&o instanceof Map?o.forEach((n,e)=>t.set(e,n)):t instanceof Set&&o instanceof Set&&o.forEach(t.add,t);for(const n in o){if(!o.hasOwnProperty(n))continue;const e=o[n],s=t[n];$(s)&&$(e)&&t.hasOwnProperty(n)&&!R(e)&&!L(e)?t[n]=O(s,e):t[n]=e}return t}const Y=Symbol();function dt(t){return Object.defineProperty(t,Y,{})}function ht(t){return!$(t)||!Object.prototype.hasOwnProperty.call(t,Y)}const{assign:h}=Object;function bt(t){return!!(R(t)&&t.effect)}function St(t,o,n,e){const{state:s,actions:c,getters:i}=o,p=n.state.value[t];let S;function b(){p||(n.state.value[t]=s?s():{});const v=at(n.state.value[t]);return h(v,c,Object.keys(i||{}).reduce((m,y)=>(m[y]=q(Q(()=>{A(n);const _=n._s.get(t);return i[y].call(_,_)})),m),{}))}return S=Z(t,b,o,n,e,!0),S}function Z(t,o,n={},e,s,c){let i;const p=h({actions:{}},n),S={deep:!0};let b,v,m=[],y=[],_;const j=e.state.value[t];!c&&!j&&(e.state.value[t]={}),G({});let N;function F(u){let r;b=v=!1,typeof u=="function"?(u(e.state.value[t]),r={type:x.patchFunction,storeId:t,events:_}):(O(e.state.value[t],u),r={type:x.patchObject,payload:u,storeId:t,events:_});const f=N=Symbol();ft().then(()=>{N===f&&(b=!0)}),v=!0,g(m,r,e.state.value[t])}const k=c?function(){const{state:r}=n,f=r?r():{};this.$patch(P=>{h(P,f)})}:X;function M(){i.stop(),m=[],y=[],e._s.delete(t)}const K=(u,r="")=>{if(V in u)return u[I]=r,u;const f=function(){A(e);const P=Array.from(arguments),d=[],E=[];function et(a){d.push(a)}function nt(a){E.push(a)}g(y,{args:P,name:f[I],store:l,after:et,onError:nt});let w;try{w=u.apply(this&&this.$id===t?this:l,P)}catch(a){throw g(E,a),a}return w instanceof Promise?w.then(a=>(g(d,a),a)).catch(a=>(g(E,a),Promise.reject(a))):(g(d,w),w)};return f[V]=!0,f[I]=r,f},tt={_p:e,$id:t,$onAction:U.bind(null,y),$patch:F,$reset:k,$subscribe(u,r={}){const f=U(m,u,r.detached,()=>P()),P=i.run(()=>st(()=>e.state.value[t],d=>{(r.flush==="sync"?v:b)&&u({storeId:t,type:x.direct,events:_},d)},h({},S,r)));return f},$dispose:M},l=ut(tt);e._s.set(t,l);const C=(e._a&&e._a.runWithContext||lt)(()=>e._e.run(()=>(i=z()).run(()=>o({action:K}))));for(const u in C){const r=C[u];if(R(r)&&!bt(r)||L(r))c||(j&&ht(r)&&(R(r)?r.value=j[u]:O(r,j[u])),e.state.value[t][u]=r);else if(typeof r=="function"){const f=K(r,u);C[u]=f,p.actions[u]=r}}return h(l,C),h(J(l),C),Object.defineProperty(l,"$state",{get:()=>e.state.value[t],set:u=>{F(r=>{h(r,u)})}}),e._p.forEach(u=>{h(l,i.run(()=>u({store:l,app:e._a,pinia:e,options:p})))}),j&&c&&n.hydrate&&n.hydrate(l.$state,j),b=!0,v=!0,l}/*! #__NO_SIDE_EFFECTS__ */function wt(t,o,n){let e;const s=typeof o=="function";e=s?n:o;function c(i,p){const S=B();return i=i||(S?D(H,null):null),i&&A(i),i=W,i._s.has(t)||(s?Z(t,o,e,i):St(t,e,i)),i._s.get(t)}return c.$id=t,c}let T="Store";function xt(t){T=t}function Rt(...t){return t.reduce((o,n)=>(o[n.$id+T]=function(){return n(this.$pinia)},o),{})}function vt(t,o){return Array.isArray(o)?o.reduce((n,e)=>(n[e]=function(){return t(this.$pinia)[e]},n),{}):Object.keys(o).reduce((n,e)=>(n[e]=function(){const s=t(this.$pinia),c=o[e];return typeof c=="function"?c.call(this,s):s[c]},n),{})}const At=vt;function Et(t,o){return Array.isArray(o)?o.reduce((n,e)=>(n[e]=function(...s){return t(this.$pinia)[e](...s)},n),{}):Object.keys(o).reduce((n,e)=>(n[e]=function(...s){return t(this.$pinia)[o[e]](...s)},n),{})}function It(t,o){return Array.isArray(o)?o.reduce((n,e)=>(n[e]={get(){return t(this.$pinia)[e]},set(s){return t(this.$pinia)[e]=s}},n),{}):Object.keys(o).reduce((n,e)=>(n[e]={get(){return t(this.$pinia)[o[e]]},set(s){return t(this.$pinia)[o[e]]=s}},n),{})}function $t(t){const o=J(t),n={};for(const e in o){const s=o[e];s.effect?n[e]=Q({get:()=>t[e],set(c){t[e]=c}}):(R(s)||L(s))&&(n[e]=it(t,e))}return n}export{x as MutationType,Ct as acceptHMRUpdate,gt as createPinia,wt as defineStore,pt as disposePinia,Pt as getActivePinia,Et as mapActions,At as mapGetters,vt as mapState,Rt as mapStores,It as mapWritableState,A as setActivePinia,xt as setMapStoreSuffix,ht as shouldHydrate,dt as skipHydrate,$t as storeToRefs};
