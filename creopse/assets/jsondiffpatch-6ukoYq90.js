function de(s){var e;const t=/^\/(.*)\/([gimyu]*)$/.exec(s.toString());if(!t)throw new Error("Invalid RegExp");return new RegExp((e=t[1])!==null&&e!==void 0?e:"",t[2])}function T(s){if(typeof s!="object")return s;if(s===null)return null;if(Array.isArray(s))return s.map(T);if(s instanceof Date)return new Date(s.getTime());if(s instanceof RegExp)return de(s);const e={};for(const t in s)Object.prototype.hasOwnProperty.call(s,t)&&(e[t]=T(s[t]));return e}function ue(s,e){if(s.length===0)throw new Error("Expected a non-empty array")}function he(s,e){if(s.length<2)throw new Error("Expected an array with at least 2 items")}const ce=s=>s[s.length-1];class S{setResult(e){return this.result=e,this.hasResult=!0,this}exit(){return this.exiting=!0,this}push(e,t){return e.parent=this,typeof t<"u"&&(e.childName=t),e.root=this.root||this,e.options=e.options||this.options,this.children?(ue(this.children),ce(this.children).next=e,this.children.push(e)):(this.children=[e],this.nextAfterChildren=this.next||null,this.next=e),e.next=this,this}}class $ extends S{constructor(e,t){super(),this.left=e,this.right=t,this.pipe="diff"}prepareDeltaResult(e){var t,i,r,n;if(typeof e=="object"&&(!((t=this.options)===null||t===void 0)&&t.omitRemovedValues&&Array.isArray(e)&&e.length>1&&(e.length===2||e[2]===0||e[2]===3)&&(e[0]=0),!((i=this.options)===null||i===void 0)&&i.cloneDiffValues)){const l=typeof((r=this.options)===null||r===void 0?void 0:r.cloneDiffValues)=="function"?(n=this.options)===null||n===void 0?void 0:n.cloneDiffValues:T;typeof e[0]=="object"&&(e[0]=l(e[0])),typeof e[1]=="object"&&(e[1]=l(e[1]))}return e}setResult(e){return this.prepareDeltaResult(e),super.setResult(e)}}class V extends S{constructor(e,t){super(),this.left=e,this.delta=t,this.pipe="patch"}}class B extends S{constructor(e){super(),this.delta=e,this.pipe="reverse"}}class k{constructor(e){this.name=e,this.filters=[]}process(e){if(!this.processor)throw new Error("add this pipe to a processor before using it");const t=this.debug,i=this.filters.length,r=e;for(let n=0;n<i;n++){const l=this.filters[n];if(l&&(t&&this.log(`filter: ${l.filterName}`),l(r),typeof r=="object"&&r.exiting)){r.exiting=!1;break}}!r.next&&this.resultCheck&&this.resultCheck(r)}log(e){console.log(`[jsondiffpatch] ${this.name} pipe, ${e}`)}append(...e){return this.filters.push(...e),this}prepend(...e){return this.filters.unshift(...e),this}indexOf(e){if(!e)throw new Error("a filter name is required");for(let t=0;t<this.filters.length;t++){const i=this.filters[t];if(i?.filterName===e)return t}throw new Error(`filter not found: ${e}`)}list(){return this.filters.map(e=>e.filterName)}after(e,...t){const i=this.indexOf(e);return this.filters.splice(i+1,0,...t),this}before(e,...t){const i=this.indexOf(e);return this.filters.splice(i,0,...t),this}replace(e,...t){const i=this.indexOf(e);return this.filters.splice(i,1,...t),this}remove(e){const t=this.indexOf(e);return this.filters.splice(t,1),this}clear(){return this.filters.length=0,this}shouldHaveResult(e){return e===!1?(this.resultCheck=null,this):this.resultCheck?this:(this.resultCheck=t=>{if(!t.hasResult){console.log(t);const i=new Error(`${this.name} failed`);throw i.noResult=!0,i}},this)}}class pe{constructor(e){this.selfOptions=e||{},this.pipes={}}options(e){return e&&(this.selfOptions=e),this.selfOptions}pipe(e,t){let i=t;if(typeof e=="string"){if(typeof i>"u")return this.pipes[e];this.pipes[e]=i}if(e&&e.name){if(i=e,i.processor===this)return i;this.pipes[i.name]=i}if(!i)throw new Error(`pipe is not defined: ${e}`);return i.processor=this,i}process(e,t){let i=e;i.options=this.options();let r=t||e.pipe||"default",n;for(;r;)typeof i.nextAfterChildren<"u"&&(i.next=i.nextAfterChildren,i.nextAfterChildren=null),typeof r=="string"&&(r=this.pipe(r)),r.process(i),n=r,r=null,i&&i.next&&(i=i.next,r=i.pipe||n);return i.hasResult?i.result:void 0}}const me=(s,e,t,i)=>s[t]===e[i],ye=(s,e,t,i)=>{var r,n,l;const o=s.length,a=e.length;let d,f;const c=new Array(o+1);for(d=0;d<o+1;d++){const p=new Array(a+1);for(f=0;f<a+1;f++)p[f]=0;c[d]=p}for(c.match=t,d=1;d<o+1;d++){const p=c[d];if(p===void 0)throw new Error("LCS matrix row is undefined");const u=c[d-1];if(u===void 0)throw new Error("LCS matrix row is undefined");for(f=1;f<a+1;f++)t(s,e,d-1,f-1,i)?p[f]=((r=u[f-1])!==null&&r!==void 0?r:0)+1:p[f]=Math.max((n=u[f])!==null&&n!==void 0?n:0,(l=p[f-1])!==null&&l!==void 0?l:0)}return c},ve=(s,e,t,i)=>{let r=e.length,n=t.length;const l={sequence:[],indices1:[],indices2:[]};for(;r!==0&&n!==0;){if(s.match===void 0)throw new Error("LCS matrix match function is undefined");if(s.match(e,t,r-1,n-1,i))l.sequence.unshift(e[r-1]),l.indices1.unshift(r-1),l.indices2.unshift(n-1),--r,--n;else{const a=s[r];if(a===void 0)throw new Error("LCS matrix row is undefined");const d=a[n-1];if(d===void 0)throw new Error("LCS matrix value is undefined");const f=s[r-1];if(f===void 0)throw new Error("LCS matrix row is undefined");const c=f[n];if(c===void 0)throw new Error("LCS matrix value is undefined");d>c?--n:--r}}return l},ge=(s,e,t,i)=>{const r=i||{},n=ye(s,e,t||me,r);return ve(n,s,e,r)},we={get:ge},A=3;function be(s,e,t,i){for(let r=0;r<t;r++){const n=s[r];for(let l=0;l<i;l++){const o=e[l];if(r!==l&&n===o)return!0}}return!1}function M(s,e,t,i,r){const n=s[t],l=e[i];if(n===l)return!0;if(typeof n!="object"||typeof l!="object")return!1;const o=r.objectHash;if(!o)return r.matchByPosition&&t===i;r.hashCache1=r.hashCache1||[];let a=r.hashCache1[t];if(typeof a>"u"&&(r.hashCache1[t]=a=o(n,t)),typeof a>"u")return!1;r.hashCache2=r.hashCache2||[];let d=r.hashCache2[i];return typeof d>"u"&&(r.hashCache2[i]=d=o(l,i)),typeof d>"u"?!1:a===d}const W=function(e){var t,i,r,n,l;if(!e.leftIsArray)return;const o={objectHash:(t=e.options)===null||t===void 0?void 0:t.objectHash,matchByPosition:(i=e.options)===null||i===void 0?void 0:i.matchByPosition};let a=0,d=0,f,c,p;const u=e.left,g=e.right,w=u.length,h=g.length;let m;for(w>0&&h>0&&!o.objectHash&&typeof o.matchByPosition!="boolean"&&(o.matchByPosition=!be(u,g,w,h));a<w&&a<h&&M(u,g,a,a,o);)f=a,m=new $(u[f],g[f]),e.push(m,f),a++;for(;d+a<w&&d+a<h&&M(u,g,w-1-d,h-1-d,o);)c=w-1-d,p=h-1-d,m=new $(u[c],g[p]),e.push(m,p),d++;let v;if(a+d===w){if(w===h){e.setResult(void 0).exit();return}for(v=v||{_t:"a"},f=a;f<h-d;f++)v[f]=[g[f]],e.prepareDeltaResult(v[f]);e.setResult(v).exit();return}if(a+d===h){for(v=v||{_t:"a"},f=a;f<w-d;f++){const R=`_${f}`;v[R]=[u[f],0,0],e.prepareDeltaResult(v[R])}e.setResult(v).exit();return}o.hashCache1=void 0,o.hashCache2=void 0;const y=u.slice(a,w-d),b=g.slice(a,h-d),_=we.get(y,b,M,o),j=[];for(v=v||{_t:"a"},f=a;f<w-d;f++)if(_.indices1.indexOf(f-a)<0){const R=`_${f}`;v[R]=[u[f],0,0],e.prepareDeltaResult(v[R]),j.push(f)}let N=!0;!((r=e.options)===null||r===void 0)&&r.arrays&&e.options.arrays.detectMove===!1&&(N=!1);let D=!1;!((l=(n=e.options)===null||n===void 0?void 0:n.arrays)===null||l===void 0)&&l.includeValueOnMove&&(D=!0);const I=j.length;for(f=a;f<h-d;f++){const R=_.indices2.indexOf(f-a);if(R<0){let q=!1;if(N&&I>0)for(let F=0;F<I;F++){c=j[F];const O=c===void 0?void 0:v[`_${c}`];if(c!==void 0&&O&&M(y,b,c-a,f-a,o)){O.splice(1,2,f,A),O.splice(1,2,f,A),D||(O[0]=""),p=f,m=new $(u[c],g[p]),e.push(m,p),j.splice(F,1),q=!0;break}}q||(v[f]=[g[f]],e.prepareDeltaResult(v[f]))}else{if(_.indices1[R]===void 0)throw new Error(`Invalid indexOnArray2: ${R}, seq.indices1: ${_.indices1}`);if(c=_.indices1[R]+a,_.indices2[R]===void 0)throw new Error(`Invalid indexOnArray2: ${R}, seq.indices2: ${_.indices2}`);p=_.indices2[R]+a,m=new $(u[c],g[p]),e.push(m,p)}}e.setResult(v).exit()};W.filterName="arrays";const K={numerically(s,e){return s-e},numericallyBy(s){return(e,t)=>e[s]-t[s]}},Q=function(e){var t;if(!e.nested)return;const i=e.delta;if(i._t!=="a")return;let r,n;const l=i,o=e.left;let a=[],d=[];const f=[];for(r in l)if(r!=="_t")if(r[0]==="_"){const u=r;if(l[u]!==void 0&&(l[u][2]===0||l[u][2]===A))a.push(Number.parseInt(r.slice(1),10));else throw new Error(`only removal or move can be applied at original array indices, invalid diff type: ${(t=l[u])===null||t===void 0?void 0:t[2]}`)}else{const u=r;l[u].length===1?d.push({index:Number.parseInt(u,10),value:l[u][0]}):f.push({index:Number.parseInt(u,10),delta:l[u]})}for(a=a.sort(K.numerically),r=a.length-1;r>=0;r--){if(n=a[r],n===void 0)continue;const u=l[`_${n}`],g=o.splice(n,1)[0];u?.[2]===A&&d.push({index:u[1],value:g})}d=d.sort(K.numericallyBy("index"));const c=d.length;for(r=0;r<c;r++){const u=d[r];u!==void 0&&o.splice(u.index,0,u.value)}const p=f.length;if(p>0)for(r=0;r<p;r++){const u=f[r];if(u===void 0)continue;const g=new V(o[u.index],u.delta);e.push(g,u.index)}if(!e.children){e.setResult(o).exit();return}e.exit()};Q.filterName="arrays";const U=function(e){if(!e||!e.children||e.delta._t!=="a")return;const i=e.left,r=e.children.length;for(let n=0;n<r;n++){const l=e.children[n];if(l===void 0)continue;const o=l.childName;i[o]=l.result}e.setResult(i).exit()};U.filterName="arraysCollectChildren";const z=function(e){if(!e.nested){const r=e.delta;if(r[2]===A){const n=r;e.newName=`_${n[1]}`,e.setResult([n[0],Number.parseInt(e.childName.substring(1),10),A]).exit()}return}const t=e.delta;if(t._t!=="a")return;const i=t;for(const r in i){if(r==="_t")continue;const n=new B(i[r]);e.push(n,r)}e.exit()};z.filterName="arrays";const _e=(s,e,t)=>{if(typeof e=="string"&&e[0]==="_")return Number.parseInt(e.substring(1),10);if(Array.isArray(t)&&t[2]===0)return`_${e}`;let i=+e;for(const r in s){const n=s[r];if(Array.isArray(n))if(n[2]===A){const l=Number.parseInt(r.substring(1),10),o=n[1];if(o===+e)return l;l<=i&&o>i?i++:l>=i&&o<i&&i--}else n[2]===0?Number.parseInt(r.substring(1),10)<=i&&i++:n.length===1&&Number.parseInt(r,10)<=i&&i--}return i},X=s=>{if(!s||!s.children)return;const e=s.delta;if(e._t!=="a")return;const t=e,i=s.children.length,r={_t:"a"};for(let n=0;n<i;n++){const l=s.children[n];if(l===void 0)continue;let o=l.newName;if(typeof o>"u"){if(l.childName===void 0)throw new Error("child.childName is undefined");o=_e(t,l.childName,l.result)}r[o]!==l.result&&(r[o]=l.result)}s.setResult(r).exit()};X.filterName="arraysCollectChildren";const G=function(e){e.left instanceof Date?(e.right instanceof Date?e.left.getTime()!==e.right.getTime()?e.setResult([e.left,e.right]):e.setResult(void 0):e.setResult([e.left,e.right]),e.exit()):e.right instanceof Date&&e.setResult([e.left,e.right]).exit()};G.filterName="dates";const J=s=>{if(!s||!s.children)return;const e=s.children.length;let t=s.result;for(let i=0;i<e;i++){const r=s.children[i];if(r!==void 0&&!(typeof r.result>"u")){if(t=t||{},r.childName===void 0)throw new Error("diff child.childName is undefined");t[r.childName]=r.result}}t&&s.leftIsArray&&(t._t="a"),s.setResult(t).exit()};J.filterName="collectChildren";const Y=s=>{var e;if(s.leftIsArray||s.leftType!=="object")return;const t=s.left,i=s.right,r=(e=s.options)===null||e===void 0?void 0:e.propertyFilter;for(const n in t){if(!Object.prototype.hasOwnProperty.call(t,n)||r&&!r(n,s))continue;const l=new $(t[n],i[n]);s.push(l,n)}for(const n in i)if(Object.prototype.hasOwnProperty.call(i,n)&&!(r&&!r(n,s))&&typeof t[n]>"u"){const l=new $(void 0,i[n]);s.push(l,n)}if(!s.children||s.children.length===0){s.setResult(void 0).exit();return}s.exit()};Y.filterName="objects";const Z=function(e){if(!e.nested)return;const t=e.delta;if(t._t)return;const i=t;for(const r in i){const n=new V(e.left[r],i[r]);e.push(n,r)}e.exit()};Z.filterName="objects";const x=function(e){if(!e||!e.children||e.delta._t)return;const i=e.left,r=e.children.length;for(let n=0;n<r;n++){const l=e.children[n];if(l===void 0)continue;const o=l.childName;Object.prototype.hasOwnProperty.call(e.left,o)&&l.result===void 0?delete i[o]:i[o]!==l.result&&(i[o]=l.result)}e.setResult(i).exit()};x.filterName="collectChildren";const ee=function(e){if(!e.nested||e.delta._t)return;const i=e.delta;for(const r in i){const n=new B(i[r]);e.push(n,r)}e.exit()};ee.filterName="objects";const te=s=>{if(!s||!s.children||s.delta._t)return;const t=s.children.length,i={};for(let r=0;r<t;r++){const n=s.children[r];if(n===void 0)continue;const l=n.childName;i[l]!==n.result&&(i[l]=n.result)}s.setResult(i).exit()};te.filterName="collectChildren";const P=2,Re=60;let L=null;function ie(s,e){var t;if(!L){let i;if(!((t=s?.textDiff)===null||t===void 0)&&t.diffMatchPatch)i=new s.textDiff.diffMatchPatch;else{if(!e)return null;const r=new Error("The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.");throw r.diff_match_patch_not_found=!0,r}L={diff:(r,n)=>i.patch_toText(i.patch_make(r,n)),patch:(r,n)=>{const l=i.patch_apply(i.patch_fromText(n),r);for(const o of l[1])if(!o){const a=new Error("text patch failed");throw a.textPatchFailed=!0,a}return l[0]}}}return L}const re=function(e){var t,i;if(e.leftType!=="string")return;const r=e.left,n=e.right,l=((i=(t=e.options)===null||t===void 0?void 0:t.textDiff)===null||i===void 0?void 0:i.minLength)||Re;if(r.length<l||n.length<l){e.setResult([r,n]).exit();return}const o=ie(e.options);if(!o){e.setResult([r,n]).exit();return}const a=o.diff;e.setResult([a(r,n),0,P]).exit()};re.filterName="texts";const ne=function(e){if(e.nested)return;const t=e.delta;if(t[2]!==P)return;const i=t,r=ie(e.options,!0).patch;e.setResult(r(e.left,i[0])).exit()};ne.filterName="texts";const je=s=>{var e,t,i;const r=/^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/,n=s.split(`
`);for(let l=0;l<n.length;l++){const o=n[l];if(o===void 0)continue;const a=o.slice(0,1);if(a==="@"){const d=r.exec(o);if(d!==null){const f=l;n[f]=`@@ -${d[3]},${d[4]} +${d[1]},${d[2]} @@`}}else if(a==="+"){if(n[l]=`-${(e=n[l])===null||e===void 0?void 0:e.slice(1)}`,((t=n[l-1])===null||t===void 0?void 0:t.slice(0,1))==="+"){const d=n[l];n[l]=n[l-1],n[l-1]=d}}else a==="-"&&(n[l]=`+${(i=n[l])===null||i===void 0?void 0:i.slice(1)}`)}return n.join(`
`)},se=function(e){if(e.nested)return;const t=e.delta;if(t[2]!==P)return;const i=t;e.setResult([je(i[0]),0,P]).exit()};se.filterName="texts";const le=function(e){if(e.left===e.right){e.setResult(void 0).exit();return}if(typeof e.left>"u"){if(typeof e.right=="function")throw new Error("functions are not supported");e.setResult([e.right]).exit();return}if(typeof e.right>"u"){e.setResult([e.left,0,0]).exit();return}if(typeof e.left=="function"||typeof e.right=="function")throw new Error("functions are not supported");if(e.leftType=e.left===null?"null":typeof e.left,e.rightType=e.right===null?"null":typeof e.right,e.leftType!==e.rightType){e.setResult([e.left,e.right]).exit();return}if(e.leftType==="boolean"||e.leftType==="number"){e.setResult([e.left,e.right]).exit();return}if(e.leftType==="object"&&(e.leftIsArray=Array.isArray(e.left)),e.rightType==="object"&&(e.rightIsArray=Array.isArray(e.right)),e.leftIsArray!==e.rightIsArray){e.setResult([e.left,e.right]).exit();return}e.left instanceof RegExp&&(e.right instanceof RegExp?e.setResult([e.left.toString(),e.right.toString()]).exit():e.setResult([e.left,e.right]).exit())};le.filterName="trivial";const fe=function(e){if(typeof e.delta>"u"){e.setResult(e.left).exit();return}if(e.nested=!Array.isArray(e.delta),e.nested)return;const t=e.delta;if(t.length===1){e.setResult(t[0]).exit();return}if(t.length===2){if(e.left instanceof RegExp){const i=/^\/(.*)\/([gimyu]+)$/.exec(t[1]);if(i?.[1]){e.setResult(new RegExp(i[1],i[2])).exit();return}}e.setResult(t[1]).exit();return}t.length===3&&t[2]===0&&e.setResult(void 0).exit()};fe.filterName="trivial";const oe=function(e){if(typeof e.delta>"u"){e.setResult(e.delta).exit();return}if(e.nested=!Array.isArray(e.delta),e.nested)return;const t=e.delta;if(t.length===1){e.setResult([t[0],0,0]).exit();return}if(t.length===2){e.setResult([t[1],t[0]]).exit();return}t.length===3&&t[2]===0&&e.setResult([t[0]]).exit()};oe.filterName="trivial";class ae{constructor(e){this.processor=new pe(e),this.processor.pipe(new k("diff").append(J,le,G,re,Y,W).shouldHaveResult()),this.processor.pipe(new k("patch").append(x,U,fe,ne,Z,Q).shouldHaveResult()),this.processor.pipe(new k("reverse").append(te,X,oe,se,ee,z).shouldHaveResult())}options(e){return this.processor.options(e)}diff(e,t){return this.processor.process(new $(e,t))}patch(e,t){return this.processor.process(new V(e,t))}reverse(e){return this.processor.process(new B(e))}unpatch(e,t){return this.patch(e,this.reverse(t))}clone(e){return T(e)}}let C;function Ce(s,e){return C||(C=new ae),C.diff(s,e)}function Ie(s,e){return C||(C=new ae),C.patch(s,e)}class $e{format(e,t){const i={};this.prepareContext(i);const r=i;return this.recurse(r,e,t),this.finalize(r)}prepareContext(e){e.buffer=[],e.out=function(...t){if(!this.buffer)throw new Error("context buffer is not initialized");this.buffer.push(...t)}}typeFormattterNotFound(e,t){throw new Error(`cannot format delta type: ${t}`)}typeFormattterErrorFormatter(e,t,i,r,n,l,o){}finalize({buffer:e}){return Array.isArray(e)?e.join(""):""}recurse(e,t,i,r,n,l,o){const d=t&&l?l.value:i;if(typeof t>"u"&&typeof r>"u")return;const f=this.getDeltaType(t,l),c=f==="node"?t._t==="a"?"array":"object":"";typeof r<"u"?this.nodeBegin(e,r,n,f,c,o??!1):this.rootBegin(e,f,c);let p;try{p=f!=="unknown"?this[`format_${f}`]:this.typeFormattterNotFound(e,f),p.call(this,e,t,d,r,n,l)}catch(u){this.typeFormattterErrorFormatter(e,u,t,d,r,n,l),typeof console<"u"&&console.error&&console.error(u.stack)}typeof r<"u"?this.nodeEnd(e,r,n,f,c,o??!1):this.rootEnd(e,f,c)}formatDeltaChildren(e,t,i){this.forEachDeltaKey(t,i,(r,n,l,o)=>{this.recurse(e,t[r],i?i[n]:void 0,r,n,l,o)})}forEachDeltaKey(e,t,i){const r=[];if(!(e._t==="a")){const h=Object.keys(e);typeof t=="object"&&t!==null&&r.push(...Object.keys(t));for(const m of h)r.indexOf(m)>=0||r.push(m);for(let m=0;m<r.length;m++){const v=r[m];if(v===void 0)continue;const y=m===r.length-1;i(v,v,void 0,y)}return}const l={};for(const h in e)if(Object.prototype.hasOwnProperty.call(e,h)){const m=e[h];if(Array.isArray(m)&&m[2]===3){const v=m;l[v[1]]=Number.parseInt(h.substring(1))}}const o=e;let a=0,d=0;const f=Array.isArray(t)?t:void 0,c=f?f.length:Object.keys(o).reduce((h,m)=>{if(m==="_t")return h;if(m.substring(0,1)==="_"){const j=o[m],N=Number.parseInt(m.substring(1)),D=Array.isArray(j)&&j.length>=3&&j[2]===3?j[1]:void 0,I=Math.max(N,D??0);return I>h?I:h}const y=Number.parseInt(m),b=l[y],_=Math.max(b??0,y??0);return _>h?_:h},0)+1;let p=c,u;const g=(...h)=>{u&&i(...u),u=h},w=()=>{u&&i(u[0],u[1],u[2],!0)};for(;a<c||d<p||`${d}`in o;){let h=!1;const m=`_${a}`,v=`${d}`,y=d in l?l[d]:void 0;if(m in o){h=!0;const b=o[m];g(m,y??a,y?{key:`_${y}`,value:f?f[y]:void 0}:void 0,!1),Array.isArray(b)?b[2]===0?(p--,a++):(b[2],a++):a++}if(v in o){h=!0;const b=o[v],_=Array.isArray(b)&&b.length===1;g(v,y??a,y?{key:`_${y}`,value:f?f[y]:void 0}:void 0,!1),_?(p++,d++):(y===void 0&&a++,d++)}h||((f&&y===void 0||this.includeMoveDestinations!==!1)&&g(v,y??a,y?{key:`_${y}`,value:f?f[y]:void 0}:void 0,!1),y!==void 0||a++,d++)}w()}getDeltaType(e,t){if(typeof e>"u")return typeof t<"u"?"movedestination":"unchanged";if(Array.isArray(e)){if(e.length===1)return"added";if(e.length===2)return"modified";if(e.length===3&&e[2]===0)return"deleted";if(e.length===3&&e[2]===2)return"textdiff";if(e.length===3&&e[2]===3)return"moved"}else if(typeof e=="object")return"node";return"unknown"}parseTextDiff(e){var t;const i=[],r=e.split(`
@@ `);for(const n of r){const l={pieces:[]},o=(t=/^(?:@@ )?[-+]?(\d+),(\d+)/.exec(n))===null||t===void 0?void 0:t.slice(1);if(!o)throw new Error("invalid text diff format");he(o),l.location={line:o[0],chr:o[1]};const a=n.split(`
`).slice(1);for(let d=0,f=a.length;d<f;d++){const c=a[d];if(c===void 0||!c.length)continue;const p={type:"context"};c.substring(0,1)==="+"?p.type="added":c.substring(0,1)==="-"&&(p.type="deleted"),p.text=c.slice(1),l.pieces.push(p)}i.push(l)}return i}}class Ae extends $e{typeFormattterErrorFormatter(e,t){const i=typeof t=="object"&&t!==null&&"message"in t&&typeof t.message=="string"?t.message:String(t);e.out(`<pre class="jsondiffpatch-error">${E(i)}</pre>`)}formatValue(e,t){const i=typeof t>"u"?"undefined":E(JSON.stringify(t,null,2));e.out(`<pre>${i}</pre>`)}formatTextDiffString(e,t){const i=this.parseTextDiff(t);e.out('<ul class="jsondiffpatch-textdiff">');for(let r=0,n=i.length;r<n;r++){const l=i[r];if(l===void 0)return;e.out(`<li><div class="jsondiffpatch-textdiff-location"><span class="jsondiffpatch-textdiff-line-number">${l.location.line}</span><span class="jsondiffpatch-textdiff-char">${l.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`);const o=l.pieces;for(let a=0,d=o.length;a<d;a++){const f=o[a];if(f===void 0)return;e.out(`<span class="jsondiffpatch-textdiff-${f.type}">${E(decodeURI(f.text))}</span>`)}e.out("</div></li>")}e.out("</ul>")}rootBegin(e,t,i){const r=`jsondiffpatch-${t}${i?` jsondiffpatch-child-node-type-${i}`:""}`;e.out(`<div class="jsondiffpatch-delta ${r}">`)}rootEnd(e){e.out(`</div>${e.hasArrows?`<script type="text/javascript">setTimeout(${De.toString()},10);<\/script>`:""}`)}nodeBegin(e,t,i,r,n){const l=`jsondiffpatch-${r}${n?` jsondiffpatch-child-node-type-${n}`:""}`,o=typeof i=="number"&&t.substring(0,1)==="_"?t.substring(1):t;e.out(`<li class="${l}" data-key="${E(t)}"><div class="jsondiffpatch-property-name">${E(o)}</div>`)}nodeEnd(e){e.out("</li>")}format_unchanged(e,t,i){typeof i>"u"||(e.out('<div class="jsondiffpatch-value">'),this.formatValue(e,i),e.out("</div>"))}format_movedestination(e,t,i){typeof i>"u"||(e.out('<div class="jsondiffpatch-value">'),this.formatValue(e,i),e.out("</div>"))}format_node(e,t,i){const r=t._t==="a"?"array":"object";e.out(`<ul class="jsondiffpatch-node jsondiffpatch-node-type-${r}">`),this.formatDeltaChildren(e,t,i),e.out("</ul>")}format_added(e,t){e.out('<div class="jsondiffpatch-value">'),this.formatValue(e,t[0]),e.out("</div>")}format_modified(e,t){e.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">'),this.formatValue(e,t[0]),e.out('</div><div class="jsondiffpatch-value jsondiffpatch-right-value">'),this.formatValue(e,t[1]),e.out("</div>")}format_deleted(e,t){e.out('<div class="jsondiffpatch-value">'),this.formatValue(e,t[0]),e.out("</div>")}format_moved(e,t){e.out('<div class="jsondiffpatch-value">'),this.formatValue(e,t[0]),e.out(`</div><div class="jsondiffpatch-moved-destination">${t[1]}</div>`),e.out(`<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">
          <svg width="30" height="60" style="position: absolute; display: none;">
          <defs>
              <marker id="markerArrow" markerWidth="8" markerHeight="8"
                 refx="2" refy="4" stroke="#88f"
                     orient="auto" markerUnits="userSpaceOnUse">
                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />
              </marker>
          </defs>
          <path d="M30,0 Q-10,25 26,50"
            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"
          ></path>
          </svg>
      </div>`),e.hasArrows=!0}format_textdiff(e,t){e.out('<div class="jsondiffpatch-value">'),this.formatTextDiffString(e,t[0]),e.out("</div>")}}function E(s){if(typeof s=="number")return s;let e=String(s);const t=[[/&/g,"&amp;"],[/</g,"&lt;"],[/>/g,"&gt;"],[/'/g,"&apos;"],[/"/g,"&quot;"]];for(const i of t)e=e.replace(i[0],i[1]);return e}const De=function(e){const t=e||document,i=({textContent:l,innerText:o})=>l||o,r=(l,o,a)=>{const d=l.querySelectorAll(o);for(let f=0,c=d.length;f<c;f++)a(d[f])},n=({children:l},o)=>{for(let a=0,d=l.length;a<d;a++){const f=l[a];f&&o(f,a)}};r(t,".jsondiffpatch-arrow",({parentNode:l,children:o,style:a})=>{const d=l,f=o[0],c=f.children[1];f.style.display="none";const p=d.querySelector(".jsondiffpatch-moved-destination");if(!(p instanceof HTMLElement))return;const u=i(p),g=d.parentNode;if(!g)return;let w;if(n(g,h=>{h.getAttribute("data-key")===u&&(w=h)}),!!w)try{const h=w.offsetTop-d.offsetTop;f.setAttribute("height",`${Math.abs(h)+6}`),a.top=`${-8+(h>0?0:h)}px`;const m=h>0?`M30,0 Q-10,${Math.round(h/2)} 26,${h-4}`:`M30,${-h} Q-10,${Math.round(-h/2)} 26,4`;c.setAttribute("d",m),f.style.display=""}catch(h){console.debug(`[jsondiffpatch] error adjusting arrows: ${h}`)}})};let H;function Ee(s,e){return H||(H=new Ae),H.format(s,e)}export{Ce as d,Ee as f,Ie as p};
